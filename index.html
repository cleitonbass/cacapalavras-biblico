<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Caça-Palavras Bíblico</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --accent: #4fc3f7;
            --light: #e8f4f8;
            --dark: #0a1128;
            --success: #4CAF50;
            --hint: #FFC107;
        }
        
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light);
            color: var(--dark);
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation;
        }
        
        header {
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
        }
        
        h1 {
            color: var(--secondary);
            font-size: clamp(1.5rem, 6vw, 2.2rem);
            margin-bottom: 5px;
        }
        
        .subtitle {
            color: var(--primary);
            font-style: italic;
            margin-bottom: 10px;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 15px;
            flex-grow: 1;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            width: 100%;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .control-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 120px;
        }
        
        label {
            margin-bottom: 3px;
            font-weight: bold;
            color: var(--secondary);
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        
        select, button {
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid var(--primary);
            background-color: white;
            font-size: clamp(0.8rem, 3vw, 1rem);
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            font-weight: bold;
            border: none;
        }
        
        button:active {
            background-color: var(--secondary);
            transform: scale(0.98);
        }
        
        button.secondary {
            background-color: var(--light);
            color: var(--dark);
            border: 2px solid var(--primary);
        }
        
        button.hint {
            background-color: var(--hint);
            color: var(--dark);
        }
        
        button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .timer-zoom-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100%;
            margin: 10px 0;
        }
        
        .timer {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            font-weight: bold;
            color: var(--secondary);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .zoom-controls {
            display: flex;
            gap: 5px;
            margin-left: 15px;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background-color: var(--primary);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }
        
        .word-search-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            margin: 10px 0;
            flex-grow: 1;
            min-height: 200px;
            overflow: auto;
            padding: 10px;
        }
        
        .word-search-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        
        .word-search {
            display: grid;
            gap: 2px;
            margin: 0 auto;
            touch-action: manipulation;
            transition: transform 0.2s;
        }
        
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #ddd;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            width: 30px;
            height: 30px;
            font-size: 20px;
            position: relative;
        }
        
        .cell.selected {
            background-color: var(--accent);
            color: white;
        }
        
        .cell.found {
            background-color: var(--word-color, var(--success)) !important;
            color: white !important;
        }
        
        .cell.hint {
            animation: hintPulse 1.5s infinite;
        }
        
        .cell.preview {
            background-color: rgba(79, 195, 247, 0.5);
        }
        
        @keyframes hintPulse {
            0% { background-color: var(--hint); }
            50% { background-color: #FFD54F; }
            100% { background-color: var(--hint); }
        }
        
        .word-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
            width: 100%;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .word-item {
            padding: 6px 12px;
            background-color: var(--light);
            border-radius: 20px;
            font-weight: bold;
            font-size: clamp(0.8rem, 3vw, 1rem);
            border-left: 4px solid var(--word-color, transparent);
        }
        
        .word-item.found {
            background-color: var(--word-color, var(--success)) !important;
            color: white !important;
            text-decoration: line-through;
            opacity: 0.8;
        }
        
        .word-item.hint {
            animation: hintPulse 1.5s infinite;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 15px;
            max-width: 95%;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            animation: modalFadeIn 0.3s;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal h2 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        
        .records-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: clamp(0.7rem, 3vw, 1rem);
        }
        
        .records-table th, .records-table td {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }
        
        .records-table th {
            background-color: var(--primary);
            color: white;
        }
        
        .records-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #f00;
            border-radius: 50%;
            animation: fall 5s linear forwards;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        .actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .actions button {
            flex: 1;
        }
        
        .word-preview {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2rem;
            z-index: 10;
            display: none;
        }
        
        /* Landscape orientation adjustments */
        @media (orientation: landscape) {
            .game-container {
                flex-direction: row;
                flex-wrap: wrap;
                align-items: flex-start;
            }
            
            .word-search-wrapper {
                order: 1;
                flex: 2;
                min-height: 300px;
            }
            
            .word-list {
                order: 2;
                flex: 1;
                margin-top: 0;
                max-height: 300px;
                justify-content: flex-start;
                align-content: flex-start;
            }
            
            .controls {
                order: 3;
                width: 100%;
            }
            
            .timer-zoom-container {
                order: 4;
            }
        }
        
        /* Tablet optimizations */
        @media (min-width: 768px) {
            .cell {
                width: 35px;
                height: 35px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Caça-Palavras Bíblico</h1>
        <p class="subtitle">Encontre todas as palavras escondidas</p>
    </header>
    
    <div class="game-container">
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="difficulty">Dificuldade:</label>
                    <select id="difficulty">
                        <option value="easy">Fácil (8x8)</option>
                        <option value="medium" selected>Médio (12x12)</option>
                        <option value="hard">Difícil (15x15)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="theme">Tema:</label>
                    <select id="theme">
                        <option value="all" selected>Todos</option>
                        <option value="people">Pessoas</option>
                        <option value="places">Lugares</option>
                        <option value="virtues">Virtudes</option>
                        <option value="books">Livros</option>
                        <option value="miracles">Milagres</option>
                        <option value="animals">Animais</option>
                        <option value="objects">Objetos</option>
                        <option value="teachings">Ensinamentos</option>
                    </select>
                </div>
            </div>
            
            <div class="actions">
                <button id="start-btn">Novo Jogo</button>
                <button id="hint-btn" class="hint">Dica (Mostrar 1 palavra)</button>
                <button id="show-solution-btn" class="secondary">Solução Completa</button>
            </div>
        </div>
        
        <div class="timer-zoom-container">
            <div class="timer">
                <span>Tempo:</span>
                <span id="timer">00:00</span>
            </div>
            <div class="zoom-controls">
                <div class="zoom-btn" id="zoom-out">-</div>
                <div class="zoom-btn" id="zoom-in">+</div>
            </div>
        </div>
        
        <div class="word-search-wrapper">
            <div class="word-search-container">
                <div id="word-search" class="word-search"></div>
            </div>
        </div>
        
        <div class="word-preview" id="word-preview"></div>
        
        <div id="word-list" class="word-list"></div>
    </div>
    
    <button id="show-records">Ver Recordes</button>
    
    <div id="records-modal" class="modal">
        <div class="modal-content">
            <h2>Recordes</h2>
            <table class="records-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Nome</th>
                        <th>Tempo</th>
                        <th>Dificuldade</th>
                        <th>Tema</th>
                    </tr>
                </thead>
                <tbody id="records-body">
                    <!-- Records will be inserted here -->
                </tbody>
            </table>
            <button id="close-modal">Fechar</button>
        </div>
    </div>
    
    <script>
        // Banco de palavras ampliado com mais de 400 palavras
        const biblicalWords = {
            all: [
                "AMOR", "PAZ", "FÉ", "JESUS", "CRISTO", "DEUS", "ESPÍRITO", "SANTO", 
                "IGREJA", "BÍBLIA", "SALVAÇÃO", "GRAÇA", "PERDÃO", "ORAÇÃO", "LOUVOR",
                "ADORAÇÃO", "SERVO", "PROFETAS", "APÓSTOLOS", "MILAGRES", "PARÁBOLAS",
                "MESSIAS", "REDENÇÃO", "SACRIFÍCIO", "ALIANÇA", "PROMESSA", "REINO",
                "ETERNO", "JUSTIÇA", "MISERICÓRDIA", "HUMILDADE", "SABEDORIA", "VERDADE",
                "VIDA", "CAMINHO", "ESPEREANÇA", "CARIDADE", "BENÇÃO", "MANDAMENTO",
                "ARREPENDIMENTO", "BATISMO", "COMUNHÃO", "DISCIPULO", "EVANGELHO", "GLÓRIA",
				"ABRAÃO", "MOISÉS", "DAVI", "SALOMÃO", "PAULO", "PEDRO", "JOÃO", "TIAGO",
                "MARIA", "JOSÉ", "ELIAS", "ELISEU", "NOÉ", "JÓ", "JEREMIAS", "ISAÍAS",
                "DANIEL", "JONAS", "LÓ", "RUTE", "ESTER", "DEBORA", "SARA", "REBECA",
                "ANA", "SAMUEL", "JOSUÉ", "CAIM", "ABEL", "LUCAS", "MARCO", "MATEUS",
                "ZACARIAS", "ELI", "SAUL", "ABSALÃO", "BALTASAR", "MELQUISEDEQUE", "TIMÓTEO",
                "BARNABÉ", "SILAS", "ÁQUILA", "PRISCA", "LÍDIA", "DORCAS", "ESTÊVÃO", "FELIPE",
				"JERUSALÉM", "BELÉM", "NAZARÉ", "JORDÃO", "SINAI", "GALILEIA", "JUDÁ",
                "BABILÔNIA", "EGITO", "MARVERMELHO", "BETEL", "JERICÓ", "SAMARIA",
                "CAFARNAUM", "ANTIOQUIA", "CORINTO", "ÉFESO", "FILIPOS", "TESSALÔNICA",
                "GÉTSEMANI", "GOLGOTA", "BETÂNIA", "SODOMA", "GOMORRA", "NÍNIVE", "DAMASCO",
                "ATENAS", "ROMA", "PATMOS", "CANAÃ", "ARARATE", "ARMAGEDOM", "JOPE",
                "BABILONIA", "ASHDODE", "CESAREIA", "DAN", "ENOM", "GABA", "HEBRON", "JARMUTE",
				"AMOR", "FÉ", "ESPERANÇA", "PAZ", "ALEGRIA", "PACIÊNCIA", "BONDADE",
                "BENIGNIDADE", "FIDELIDADE", "DOMÍNIO", "HUMILDADE", "PERDÃO", "MISERICÓRDIA",
                "JUSTIÇA", "SABEDORIA", "PRUDÊNCIA", "TEMPERANÇA", "FORTALEZA", "SANTIDADE",
                "GENEROSIDADE", "COMPAIXÃO", "GRATIDÃO", "LEALDADE", "PUREZA", "SINCERIDADE",
                "CONTENTAMENTO", "PERSEVERANÇA", "RESPEITO", "TOLERÂNCIA", "UNIÃO",
				"GÊNESIS", "ÊXODO", "LEVÍTICO", "NÚMEROS", "DEUTERONÔMIO", "JOSUÉ", "JUÍZES",
                "RUTE", "SAMUEL", "REIS", "CRÔNICAS", "ESDRAS", "NEEMIAS", "ESTER", "JÓ",
                "SALMOS", "PROVÉRBIOS", "ECLESIASTES", "CANTARES", "ISAÍAS", "JEREMIAS",
                "LAMENTAÇÕES", "EZEQUIEL", "DANIEL", "OSÉIAS", "JOEL", "AMÓS", "OBADIAS",
                "JONAS", "MIQUEIAS", "NAUM", "HABACUQUE", "SOFONIAS", "AGEU", "ZACARIAS", "MALAQUIAS",
                "MATEUS", "MARCOS", "LUCAS", "JOÃO", "ATOS", "ROMANOS", "CORÍNTIOS", "GÁLATAS",
				"PÃES", "PEIXES", "ÁGUA", "VINHO", "CEGOS", "PARALÍTICO", "RESSURREIÇÃO",
                "TEMPESTADE", "LÁZARO", "FILHA", "SURDOS", "MUDOS", "LEPROSOS", "CEGUEIRA",
                "SANGUE", "CHUVA", "SOL", "SOMBRA", "LÍNGUAS", "FOGO", "NUVEM", "MANÁ",
                "CODORNA", "MAR", "RIO", "TERREMOTO", "TÚMULO", "REDES", "FIGUEIRA",
                "MÃO", "PÉ", "FILHO", "MULHER", "ENFERMO", "ENDEMONHADO", "SANGUE", "SUOR",
				"LEÃO", "CORDEIRO", "PEIXE", "POMBA", "SERPENTE", "BALEIA", "GAFANHOTO",
                "ÁGUIA", "OVELHA", "BODE", "CAMELO", "BURRO", "GALO", "CAVALO", "PORCO",
                "CÃO", "GATO", "RÃ", "VACA", "TOURO", "JUMENTO", "CORVO", "PARDAL", "ABELHA",
                "GAFANHOTO", "LOCUSTA", "ESCORPIÃO", "URSO", "LOBO", "DRAGÃO", "CORUJA",
				"ARCA", "TROMBETA", "ALTAR", "COROA", "CRUZ", "SINO", "CÁLICE", "ESPADA",
                "ANEL", "MANÁ", "TÁBUA", "VÉU", "CANDELABRO", "SINO", "PÃO", "VINHO",
                "ÓLEO", "INCENSO", "MOEDA", "CESTA", "REDE", "CAJUELA", "LANÇA", "MARTELO",
                "PREGO", "CORDEIRO", "SACO", "CINTO", "SANDÁLIA", "MANTO", "TÚNICA", "CETRO",
                "COLUNA", "PEDRA", "SELO", "TENDAS", "VÉU", "ZIMBORIO", "COLCHÃO",
				"SERMÃO", "MONTANHA", "BEMAVENTURANÇAS", "PARÁBOLA", "SEMEADOR", "TRIGO",
                "JOIO", "PÉROLA", "TESOURO", "SERVO", "TALENTOS", "OVELHAS", "BODES",
                "VIZINHO", "SAMARITANO", "FILHO", "PRÓDIGO", "FARISEU", "PUBLICANO",
                "JUIZ", "VIÚVA", "LÁMPADA", "SAL", "LUZ", "CIDADE", "MONTE", "PORTÃO",
                "CAMINHO", "VERDADE", "VIDA", "PORTAS", "PEDRAS", "TESOUROS", "PÁSSAROS",
                "LÍRIOS", "CASA", "ROCHA", "AREIA", "JUGOS", "FARDOS",
            ],
            people: [
                "ABRAÃO", "MOISÉS", "DAVI", "SALOMÃO", "PAULO", "PEDRO", "JOÃO", "TIAGO",
                "MARIA", "JOSÉ", "ELIAS", "ELISEU", "NOÉ", "JÓ", "JEREMIAS", "ISAÍAS",
                "DANIEL", "JONAS", "LÓ", "RUTE", "ESTER", "DEBORA", "SARA", "REBECA",
                "ANA", "SAMUEL", "JOSUÉ", "CAIM", "ABEL", "LUCAS", "MARCO", "MATEUS",
                "ZACARIAS", "ELI", "SAUL", "ABSALÃO", "BALTASAR", "MELQUISEDEQUE", "TIMÓTEO",
                "BARNABÉ", "SILAS", "ÁQUILA", "PRISCA", "LÍDIA", "DORCAS", "ESTÊVÃO", "FELIPE",
            ],
            places: [
                "JERUSALÉM", "BELÉM", "NAZARÉ", "JORDÃO", "SINAI", "GALILEIA", "JUDÁ",
                "BABILÔNIA", "EGITO", "MARVERMELHO", "BETEL", "JERICÓ", "SAMARIA",
                "CAFARNAUM", "ANTIOQUIA", "CORINTO", "ÉFESO", "FILIPOS", "TESSALÔNICA",
                "GÉTSEMANI", "GOLGOTA", "BETÂNIA", "SODOMA", "GOMORRA", "NÍNIVE", "DAMASCO",
                "ATENAS", "ROMA", "PATMOS", "CANAÃ", "ARARATE", "ARMAGEDOM", "JOPE",
                "BABILONIA", "ASHDODE", "CESAREIA", "DAN", "ENOM", "GABA", "HEBRON", "JARMUTE"
            ],
            virtues: [
                "AMOR", "FÉ", "ESPERANÇA", "PAZ", "ALEGRIA", "PACIÊNCIA", "BONDADE",
                "BENIGNIDADE", "FIDELIDADE", "DOMÍNIO", "HUMILDADE", "PERDÃO", "MISERICÓRDIA",
                "JUSTIÇA", "SABEDORIA", "PRUDÊNCIA", "TEMPERANÇA", "FORTALEZA", "SANTIDADE",
                "GENEROSIDADE", "COMPAIXÃO", "GRATIDÃO", "LEALDADE", "PUREZA", "SINCERIDADE",
                "CONTENTAMENTO", "PERSEVERANÇA", "RESPEITO", "TOLERÂNCIA", "UNIÃO"
            ],
            books: [
                "GÊNESIS", "ÊXODO", "LEVÍTICO", "NÚMEROS", "DEUTERONÔMIO", "JOSUÉ", "JUÍZES",
                "RUTE", "SAMUEL", "REIS", "CRÔNICAS", "ESDRAS", "NEEMIAS", "ESTER", "JÓ",
                "SALMOS", "PROVÉRBIOS", "ECLESIASTES", "CANTARES", "ISAÍAS", "JEREMIAS",
                "LAMENTAÇÕES", "EZEQUIEL", "DANIEL", "OSÉIAS", "JOEL", "AMÓS", "OBADIAS",
                "JONAS", "MIQUEIAS", "NAUM", "HABACUQUE", "SOFONIAS", "AGEU", "ZACARIAS", "MALAQUIAS",
                "MATEUS", "MARCOS", "LUCAS", "JOÃO", "ATOS", "ROMANOS", "CORÍNTIOS", "GÁLATAS"
            ],
            miracles: [
                "PÃES", "PEIXES", "ÁGUA", "VINHO", "CEGOS", "PARALÍTICO", "RESSURREIÇÃO",
                "TEMPESTADE", "LÁZARO", "FILHA", "SURDOS", "MUDOS", "LEPROSOS", "CEGUEIRA",
                "SANGUE", "CHUVA", "SOL", "SOMBRA", "LÍNGUAS", "FOGO", "NUVEM", "MANÁ",
                "CODORNA", "MAR", "RIO", "TERREMOTO", "TÚMULO", "REDES", "FIGUEIRA",
                "MÃO", "PÉ", "FILHO", "MULHER", "ENFERMO", "ENDEMONHADO", "SANGUE", "SUOR"
            ],
            animals: [
                "LEÃO", "CORDEIRO", "PEIXE", "POMBA", "SERPENTE", "BALEIA", "GAFANHOTO",
                "ÁGUIA", "OVELHA", "BODE", "CAMELO", "BURRO", "GALO", "CAVALO", "PORCO",
                "CÃO", "GATO", "RÃ", "VACA", "TOURO", "JUMENTO", "CORVO", "PARDAL", "ABELHA",
                "GAFANHOTO", "LOCUSTA", "ESCORPIÃO", "URSO", "LOBO", "DRAGÃO", "CORUJA"
            ],
            objects: [
                "ARCA", "TROMBETA", "ALTAR", "COROA", "CRUZ", "SINO", "CÁLICE", "ESPADA",
                "ANEL", "MANÁ", "TÁBUA", "VÉU", "CANDELABRO", "SINO", "PÃO", "VINHO",
                "ÓLEO", "INCENSO", "MOEDA", "CESTA", "REDE", "CAJUELA", "LANÇA", "MARTELO",
                "PREGO", "CORDEIRO", "SACO", "CINTO", "SANDÁLIA", "MANTO", "TÚNICA", "CETRO",
                "COLUNA", "PEDRA", "SELO", "TENDAS", "VÉU", "ZIMBORIO", "COLCHÃO"
            ],
            teachings: [
                "SERMÃO", "MONTANHA", "BEMAVENTURANÇAS", "PARÁBOLA", "SEMEADOR", "TRIGO",
                "JOIO", "PÉROLA", "TESOURO", "SERVO", "TALENTOS", "OVELHAS", "BODES",
                "VIZINHO", "SAMARITANO", "FILHO", "PRÓDIGO", "FARISEU", "PUBLICANO",
                "JUIZ", "VIÚVA", "LÁMPADA", "SAL", "LUZ", "CIDADE", "MONTE", "PORTÃO",
                "CAMINHO", "VERDADE", "VIDA", "PORTAS", "PEDRAS", "TESOUROS", "PÁSSAROS",
                "LÍRIOS", "CASA", "ROCHA", "AREIA", "JUGOS", "FARDOS"
            ]
        };

        // Game variables
        let grid = [];
        let words = [];
        let foundWords = [];
        let selectedCells = [];
        let gameActive = false;
        let startTime;
        let timerInterval;
        let records = JSON.parse(localStorage.getItem('biblicalWordSearchRecords')) || [];
        let wordColorMap = {};
        let wordPositions = {};
        let isTouchDevice = false;
        let currentPreviewWord = '';
        let currentZoom = 1;
        const MIN_ZOOM = 0.7;
        const MAX_ZOOM = 1.5;
        const ZOOM_STEP = 0.1;
        
        // DOM elements
        const wordSearchElement = document.getElementById('word-search');
        const wordListElement = document.getElementById('word-list');
        const timerElement = document.getElementById('timer');
        const startButton = document.getElementById('start-btn');
        const difficultySelect = document.getElementById('difficulty');
        const themeSelect = document.getElementById('theme');
        const recordsModal = document.getElementById('records-modal');
        const recordsBody = document.getElementById('records-body');
        const showRecordsButton = document.getElementById('show-records');
        const closeModalButton = document.getElementById('close-modal');
        const hintButton = document.getElementById('hint-btn');
        const showSolutionButton = document.getElementById('show-solution-btn');
        const wordPreviewElement = document.getElementById('word-preview');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        
        // Initialize event listeners
        function initEventListeners() {
            startButton.addEventListener('click', startGame);
            showRecordsButton.addEventListener('click', showRecords);
            closeModalButton.addEventListener('click', () => {
                recordsModal.style.display = 'none';
            });
            hintButton.addEventListener('click', giveHint);
            showSolutionButton.addEventListener('click', showSolution);
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            
            // Handle orientation changes
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('resize', handleResize);
        }
        
        // Zoom functions
        function zoomIn() {
            if (currentZoom < MAX_ZOOM) {
                currentZoom += ZOOM_STEP;
                applyZoom();
            }
        }
        
        function zoomOut() {
            if (currentZoom > MIN_ZOOM) {
                currentZoom -= ZOOM_STEP;
                applyZoom();
            }
        }
        
        function applyZoom() {
            wordSearchElement.style.transform = `scale(${currentZoom})`;
            wordSearchElement.style.transformOrigin = 'center';
        }
        
        // Handle orientation change
        function handleOrientationChange() {
            if (gameActive && grid.length > 0) {
                setTimeout(() => {
                    renderGrid(grid);
                    adjustWordList();
                }, 100);
            }
        }
        
        // Handle window resize
        function handleResize() {
            if (gameActive && grid.length > 0) {
                renderGrid(grid);
            }
        }
        
        // Adjust word list for landscape
        function adjustWordList() {
            if (window.matchMedia("(orientation: landscape)").matches) {
                wordListElement.style.maxHeight = '300px';
                wordListElement.style.overflowY = 'auto';
            } else {
                wordListElement.style.maxHeight = 'none';
                wordListElement.style.overflowY = 'visible';
            }
        }
        
        // Detect touch device
        function detectTouchDevice() {
            try {
                document.createEvent("TouchEvent");
                isTouchDevice = true;
                return true;
            } catch (e) {
                isTouchDevice = false;
                return false;
            }
        }
        
        // Normalize string (remove accents and special characters)
        function normalizeString(str) {
            return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toUpperCase();
        }
        
        // Initialize game
        function initGame() {
            wordSearchElement.innerHTML = '';
            wordListElement.innerHTML = '';
            timerElement.textContent = '00:00';
            grid = [];
            words = [];
            foundWords = [];
            selectedCells = [];
            wordPositions = {};
            gameActive = false;
            wordColorMap = {};
            currentPreviewWord = '';
            currentZoom = 1;
            
            // Reset hint button
            hintButton.disabled = false;
            hintButton.textContent = 'Dica (Mostrar 1 palavra)';
            
            // Hide word preview
            wordPreviewElement.style.display = 'none';
            
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reset zoom
            wordSearchElement.style.transform = 'scale(1)';
        }
        
        // Start new game with improved randomization
        function startGame() {
            initGame();
            detectTouchDevice();
            
            const difficulty = difficultySelect.value;
            const theme = themeSelect.value;
            
            // Set grid size and word count based on difficulty
            let gridSize, wordCount, minWordLength;
            switch(difficulty) {
                case 'easy':
                    gridSize = 8;
                    wordCount = 8;
                    minWordLength = 3;
                    break;
                case 'medium':
                    gridSize = 12;
                    wordCount = 12;
                    minWordLength = 4;
                    break;
                case 'hard':
                    gridSize = 15;
                    wordCount = 18;
                    minWordLength = 5;
                    break;
                default:
                    gridSize = 12;
                    wordCount = 12;
            }
            
            // Get words based on theme
            let themeWords = biblicalWords[theme] || biblicalWords.all;
            
            // Filter words by size (difficulty)
            themeWords = themeWords.filter(word => 
                word.length >= minWordLength && word.length <= gridSize
            );
            
            // Improved randomization
            words = [];
            
            // First shuffle - Fisher-Yates algorithm
            for (let i = themeWords.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [themeWords[i], themeWords[j]] = [themeWords[j], themeWords[i]];
            }
            
            // Second shuffle for better mixing
            themeWords.sort(() => Math.random() - 0.5);
            
            // Use a Set to ensure uniqueness (normalized)
            const uniqueWords = new Set();
            let attempts = 0;
            const maxAttempts = 100;
            
            while (words.length < wordCount && attempts < maxAttempts && themeWords.length > 0) {
                attempts++;
                const word = themeWords.pop();
                const normalizedWord = normalizeString(word);
                
                if (!uniqueWords.has(normalizedWord)) {
                    uniqueWords.add(normalizedWord);
                    words.push(word);
                    wordColorMap[word] = getColorForIndex(words.length - 1);
                }
            }
            
            // Create empty grid
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
            wordPositions = {};
            
            // Place words in grid with improved algorithm
            let placementAttempts = 0;
            const maxPlacementAttempts = 10;
            
            while (placementAttempts < maxPlacementAttempts) {
                if (placeWords(grid, words)) {
                    break;
                }
                placementAttempts++;
                
                // Reset grid if placement fails
                grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
                wordPositions = {};
            }
            
            if (placementAttempts >= maxPlacementAttempts) {
                alert("Não foi possível criar um caça-palavras com as configurações atuais. Tente novamente com menos palavras ou um tema diferente.");
                return;
            }
            
            // Fill remaining spaces with random letters
            fillEmptySpaces(grid);
            
            // Render grid
            renderGrid(grid);
            
            // Render word list
            renderWordList(words);
            
            // Start timer
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
            gameActive = true;
        }
        
        // Get color for word index
        function getColorForIndex(index) {
            const colors = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE', 
                '#448AFF', '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE',
                '#B2FF59', '#EEFF41', '#FFFF00', '#FFD740', '#FFAB40',
                '#FF6E40', '#FF4081', '#7C4DFF', '#7B1FA2', '#512DA8'
            ];
            return colors[index % colors.length];
        }
        
        // Improved word placement algorithm
        function placeWords(grid, words) {
            const gridSize = grid.length;
            const directions = [
                { dr: 0, dc: 1 },   // Horizontal
                { dr: 1, dc: 0 },   // Vertical
                { dr: 1, dc: 1 },   // Diagonal down-right
                { dr: 1, dc: -1 }   // Diagonal down-left
            ];
            
            // Sort words by length (longest first) to improve placement success
            const sortedWords = [...words].sort((a, b) => b.length - a.length);
            
            for (const word of sortedWords) {
                let placed = false;
                let placementAttempts = 0;
                const maxPlacementAttempts = 50;
                
                // Try different positions and directions
                while (!placed && placementAttempts < maxPlacementAttempts) {
                    placementAttempts++;
                    
                    // Choose random direction
                    const direction = directions[Math.floor(Math.random() * directions.length)];
                    const { dr, dc } = direction;
                    
                    // Calculate possible starting positions
                    const maxRow = gridSize - (word.length - 1) * Math.max(0, dr);
                    const maxCol = gridSize - (word.length - 1) * Math.max(0, dc);
                    
                    if (maxRow <= 0 || maxCol <= 0) continue;
                    
                    // Choose random starting position
                    let row = Math.floor(Math.random() * maxRow);
                    let col = Math.floor(Math.random() * maxCol);
                    
                    // Adjust for diagonal up-left
                    if (dc === -1) {
                        col = (word.length - 1) + Math.floor(Math.random() * (gridSize - (word.length - 1)));
                    }
                    
                    // Check if cells are empty or contain matching letters
                    let canPlace = true;
                    for (let i = 0; i < word.length; i++) {
                        const r = row + i * dr;
                        const c = col + i * dc;
                        if (grid[r][c] !== '' && grid[r][c] !== word[i]) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (!canPlace) continue;
                    
                    // Store word positions
                    wordPositions[word] = [];
                    for (let i = 0; i < word.length; i++) {
                        const r = row + i * dr;
                        const c = col + i * dc;
                        wordPositions[word].push({ row: r, col: c });
                    }
                    
                    // Place the word
                    for (let i = 0; i < word.length; i++) {
                        const r = row + i * dr;
                        const c = col + i * dc;
                        grid[r][c] = word[i];
                    }
                    
                    placed = true;
                }
                
                if (!placed) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Fill empty spaces with random letters
        function fillEmptySpaces(grid) {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    if (grid[i][j] === '') {
                        grid[i][j] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }
        }
        
        // Render the grid with proper centering
        function renderGrid(grid) {
            // Preserve found cells state before recreating the grid
            const foundCellsState = [];
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                if (cell.classList.contains('found')) {
                    foundCellsState.push({
                        row: parseInt(cell.dataset.row),
                        col: parseInt(cell.dataset.col),
                        word: cell.dataset.word
                    });
                }
            });

            wordSearchElement.innerHTML = '';
            
            // Fixed cell size
            const cellSize = window.innerWidth < 768 ? 30 : 35;
            
            // Set grid template
            wordSearchElement.style.gridTemplateColumns = `repeat(${grid.length}, ${cellSize}px)`;
            wordSearchElement.style.gridTemplateRows = `repeat(${grid.length}, ${cellSize}px)`;
            
            // Apply to all cells
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = grid[i][j];
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    // Verificar se esta célula estava marcada como encontrada
                    const foundCell = foundCellsState.find(f => f.row === i && f.col === j);
                    if (foundCell) {
                        cell.classList.add('found');
                        cell.style.setProperty('--word-color', wordColorMap[foundCell.word]);
                        cell.dataset.word = foundCell.word;
                    }
                    
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.style.fontSize = `${Math.min(cellSize * 0.6, 24)}px`;
                    
                    // Add event listeners
                    cell.addEventListener('mousedown', handleCellMouseDown);
                    cell.addEventListener('mouseenter', handleCellMouseEnter);
                    cell.addEventListener('mouseup', handleCellMouseUp);
                    cell.addEventListener('touchstart', handleCellTouchStart, { passive: false });
                    cell.addEventListener('touchmove', handleCellTouchMove, { passive: false });
                    cell.addEventListener('touchend', handleCellTouchEnd);
                    
                    wordSearchElement.appendChild(cell);
                }
            }
            
            // Force reflow to ensure proper rendering
            void wordSearchElement.offsetHeight;
        }
        
        // Render the word list
        function renderWordList(words) {
            wordListElement.innerHTML = '';
            words.forEach((word, index) => {
                const wordElement = document.createElement('div');
                wordElement.className = 'word-item';
                wordElement.textContent = word;
                wordElement.dataset.word = word;
                wordElement.style.setProperty('--word-color', wordColorMap[word]);
                
                // Mark as found if already found
                if (foundWords.includes(word)) {
                    wordElement.classList.add('found');
                }
                
                wordListElement.appendChild(wordElement);
            });
            
            adjustWordList();
        }
        
        // Handle cell mouse down
        function handleCellMouseDown(e) {
            if (!gameActive) return;
            e.preventDefault();
            
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            
            selectedCells = [{ row, col }];
            updateSelectedCells();
            updateWordPreview();
        }
        
        // Handle cell mouse enter
        function handleCellMouseEnter(e) {
            if (!gameActive || selectedCells.length === 0) return;
            
            const newCell = {
                row: parseInt(e.target.dataset.row),
                col: parseInt(e.target.dataset.col)
            };
            
            updateSelection(newCell);
            updateWordPreview();
        }
        
        // Handle cell mouse up
        function handleCellMouseUp() {
            finishSelection();
            wordPreviewElement.style.display = 'none';
        }
        
        // Handle touch start
        function handleCellTouchStart(e) {
            if (!gameActive) return;
            e.preventDefault();
            
            const touch = e.changedTouches[0];
            const cell = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (cell && cell.classList.contains('cell')) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                selectedCells = [{ row, col }];
                updateSelectedCells();
                updateWordPreview();
            }
        }
        
        // Handle touch move
        function handleCellTouchMove(e) {
            if (!gameActive || selectedCells.length === 0) return;
            e.preventDefault();
            
            const touch = e.changedTouches[0];
            const cell = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (cell && cell.classList.contains('cell')) {
                const newCell = {
                    row: parseInt(cell.dataset.row),
                    col: parseInt(cell.dataset.col)
                };
                
                updateSelection(newCell);
                updateWordPreview();
            }
        }
        
        // Handle touch end
        function handleCellTouchEnd() {
            finishSelection();
            wordPreviewElement.style.display = 'none';
        }
        
        // Update word preview during selection
        function updateWordPreview() {
            if (selectedCells.length < 2) {
                wordPreviewElement.style.display = 'none';
                return;
            }
            
            // Get selected word
            let selectedWord = '';
            for (const cell of selectedCells) {
                selectedWord += grid[cell.row][cell.col];
            }
            
            // Only show preview if the word is at least 2 characters
            if (selectedWord.length >= 2) {
                wordPreviewElement.textContent = selectedWord;
                wordPreviewElement.style.display = 'block';
                currentPreviewWord = selectedWord;
            } else {
                wordPreviewElement.style.display = 'none';
                currentPreviewWord = '';
            }
        }
        
        // Update selection
        function updateSelection(newCell) {
            // Only allow straight lines
            const firstCell = selectedCells[0];
            const isHorizontal = firstCell.row === newCell.row;
            const isVertical = firstCell.col === newCell.col;
            const isDiagonal = Math.abs(firstCell.row - newCell.row) === Math.abs(firstCell.col - newCell.col);
            
            if (!isHorizontal && !isVertical && !isDiagonal) {
                return;
            }
            
            // Calculate all cells between first and new cell
            const dr = Math.sign(newCell.row - firstCell.row);
            const dc = Math.sign(newCell.col - firstCell.col);
            
            selectedCells = [];
            let r = firstCell.row;
            let c = firstCell.col;
            
            while (true) {
                selectedCells.push({ row: r, col: c });
                if (r === newCell.row && c === newCell.col) break;
                r += dr;
                c += dc;
            }
            
            updateSelectedCells();
        }
        
        // Finish selection and check word
        function finishSelection() {
            if (!gameActive || selectedCells.length < 2) {
                selectedCells = [];
                updateSelectedCells();
                return;
            }
            
            // Get selected word
            let selectedWord = '';
            for (const cell of selectedCells) {
                selectedWord += grid[cell.row][cell.col];
            }
            
            // Normalize the selected word and the words in the list
            const normalizedSelected = normalizeString(selectedWord);
            const normalizedReversed = normalizeString(selectedWord.split('').reverse().join(''));
            
            let foundWord = null;
            
            for (const word of words) {
                const normalizedWord = normalizeString(word);
                if (!foundWords.includes(word) && 
                    (normalizedSelected === normalizedWord || normalizedReversed === normalizedWord)) {
                    foundWord = word;
                    break;
                }
            }
            
            if (foundWord) {
                // Mark word as found
                foundWords.push(foundWord);

                // Highlight cells with the specific color for this word
                const cells = document.querySelectorAll('.cell');
                const wordCells = wordPositions[foundWord];

                for (const cell of wordCells) {
                    const index = cell.row * grid.length + cell.col;
                    cells[index].classList.add('found');
                    cells[index].style.setProperty('--word-color', wordColorMap[foundWord]);
                    cells[index].dataset.word = foundWord;
                }

                // Update word list
                const wordElements = document.querySelectorAll('.word-item');
                for (const el of wordElements) {
                    if (el.dataset.word === foundWord) {
                        el.classList.add('found');
                        el.style.setProperty('--word-color', wordColorMap[foundWord]);
                        break;
                    }
                }

                // Check if game is complete
                if (foundWords.length === words.length) {
                    endGame();
                }
            }
            
            selectedCells = [];
            updateSelectedCells();
        }
        
        // Update selected cells highlighting
        function updateSelectedCells() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('selected');
                cell.classList.remove('preview');
            });

            for (const cell of selectedCells) {
                const index = cell.row * grid.length + cell.col;
                cells[index].classList.add('selected');

                // Add preview class to show selection path
                if (selectedCells.length > 1) {
                    cells[index].classList.add('preview');
                }
            }
        }
        
        // Update timer display
        function updateTimer() {
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            timerElement.textContent = `${minutes}:${seconds}`;
        }
        
        // Improved hint system
        function giveHint() {
            if (!gameActive) return;
            
            // Find a word that hasn't been found yet
            const remainingWords = words.filter(word => !foundWords.includes(word));
            if (remainingWords.length === 0) return;
            
            const hintWord = remainingWords[Math.floor(Math.random() * remainingWords.length)];
            
            // Highlight the word in the list with animation
            const wordElements = document.querySelectorAll('.word-item');
            for (const el of wordElements) {
                if (el.dataset.word === hintWord) {
                    el.classList.add('hint');
                    setTimeout(() => {
                        if (!el.classList.contains('found')) {
                            el.classList.remove('hint');
                        }
                    }, 3000);
                    break;
                }
            }
            
            // Highlight the word in the grid with animation
            const cells = document.querySelectorAll('.cell');
            const wordCells = wordPositions[hintWord];
            
            // First show the first letter
            const firstCellIndex = wordCells[0].row * grid.length + wordCells[0].col;
            cells[firstCellIndex].classList.add('hint');
            
            // Then show the whole word after a delay
            setTimeout(() => {
                for (const cell of wordCells) {
                    const index = cell.row * grid.length + cell.col;
                    cells[index].classList.add('hint');
                    setTimeout(() => {
                        if (!cells[index].classList.contains('found')) {
                            cells[index].classList.remove('hint');
                        }
                    }, 2000);
                }
            }, 1000);
            
            // Disable hint button temporarily to prevent spamming
            hintButton.disabled = true;
            setTimeout(() => {
                hintButton.disabled = false;
            }, 3000);
        }
        
        // Show complete solution
        function showSolution() {
            if (!gameActive) return;
            
            // Mark all words as found
            const remainingWords = words.filter(word => !foundWords.includes(word));
            if (remainingWords.length === 0) return;

            const cells = document.querySelectorAll('.cell');

            for (const word of remainingWords) {
                foundWords.push(word);
                const wordCells = wordPositions[word];

                for (const cell of wordCells) {
                    const index = cell.row * grid.length + cell.col;
                    cells[index].classList.add('found');
                    cells[index].style.setProperty('--word-color', wordColorMap[word]);
                    cells[index].dataset.word = word;
                }

                // Update word list
                const wordElements = document.querySelectorAll('.word-item');
                for (const el of wordElements) {
                    if (el.dataset.word === word) {
                        el.classList.add('found');
                        el.style.setProperty('--word-color', wordColorMap[word]);
                        break;
                    }
                }
            }

            // End game
            endGame();
        }
        
        // End game
        function endGame() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            gameActive = false;
            
            // Calculate final time
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;
            
            // Show confetti
            createConfetti();
            
            // Prompt for name and save record
            setTimeout(() => {
                const name = prompt(`Parabéns! Você completou o caça-palavras em ${timeString}.\nDigite seu nome para o ranking:`);
                if (name) {
                    const difficulty = difficultySelect.value;
                    const theme = themeSelect.value;
                    
                    records.push({
                        name,
                        time: elapsed,
                        timeString,
                        difficulty,
                        theme,
                        date: new Date().toLocaleDateString()
                    });
                    
                    // Sort records by time (ascending)
                    records.sort((a, b) => a.time - b.time);
                    
                    // Keep only top 10 records
                    if (records.length > 10) {
                        records = records.slice(0, 10);
                    }
                    
                    // Save to localStorage
                    localStorage.setItem('biblicalWordSearchRecords', JSON.stringify(records));
                }
            }, 500);
        }
        
        // Show records
        function showRecords() {
            recordsBody.innerHTML = '';
            
            if (records.length === 0) {
                recordsBody.innerHTML = '<tr><td colspan="5">Nenhum recorde ainda!</td></tr>';
            } else {
                records.forEach((record, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${record.name}</td>
                        <td>${record.timeString}</td>
                        <td>${getDifficultyName(record.difficulty)}</td>
                        <td>${getThemeName(record.theme)}</td>
                    `;
                    recordsBody.appendChild(row);
                });
            }
            
            recordsModal.style.display = 'flex';
        }
        
        // Helper function to get difficulty name
        function getDifficultyName(difficulty) {
            switch(difficulty) {
                case 'easy': return 'Fácil';
                case 'medium': return 'Médio';
                case 'hard': return 'Difícil';
                default: return difficulty;
            }
        }
        
        // Helper function to get theme name
        function getThemeName(theme) {
            switch(theme) {
                case 'all': return 'Todos';
                case 'people': return 'Pessoas';
                case 'places': return 'Lugares';
                case 'virtues': return 'Virtudes';
                case 'books': return 'Livros';
                case 'miracles': return 'Milagres';
                case 'animals': return 'Animais';
                case 'objects': return 'Objetos';
                case 'teachings': return 'Ensinamentos';
                default: return theme;
            }
        }
        
        // Create confetti effect
        function createConfetti() {
            const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
            
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = `${Math.random() * 10 + 5}px`;
                confetti.style.height = `${Math.random() * 10 + 5}px`;
                confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
                confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                
                document.body.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    confetti.remove();
                }, 5000);
            }
        }
        
        // Initialize the game
        function initialize() {
            initEventListeners();
            initGame();
        }
        
        // Start the game when the page loads
        window.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
